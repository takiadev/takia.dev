[{"content":"[EDIT] Thanks to reddit for pointing mistakes in the first version of this article.\nHave you ever noticed how the vim keymap seems sometimes arbitrary or unbalanced? Out of all possible motions, words have three keys: w, b and e. Not only that\u0026rsquo;s a lot of real estate on your keyboard, but one could argue that in the age of modern programming moving by word is far from optimal. With the rise of so many great plugins, new actions such as jumping to a pair of character, swapping two objects, changing surroundings are better candidates for our keymap. And with the introduction of treesitter it is now possible to move by function, by variable, by loop, by variable name, \u0026hellip;by anything you can think of that is more appropriate than the old notion of a \u0026ldquo;word\u0026rdquo;.\nIt is natural, then, to wonder if we can do better: is there a way that we can free up some space on the keyboard while retaining the power of vim motions? And how can we incorporate modern motions such as jumping from function to function or jumping straight to the next for-loop?\nThe power of n/N cords My answer to these considerations is to change the behavior of the n and N keys. After all, there are four keys to do essentially the same thing but with slight variations:\nn: next search result, ;: next char-wise search result, N: previous search result, ,: previous char-wise search result. And like we said earlier, that\u0026rsquo;s a lot of real estate on the keyboard.\nIn this article we will argue to remap n and N but it works just as well if you decide to remap ; and , instead. Actually, I would even find it more convenient as ;, don\u0026rsquo;t require shift!\nThe idea here is to use n to mean next \u0026lt;something\u0026gt; and N to mean previous \u0026lt;something\u0026gt;. For the search results, we can use n/ and N/:\n1 2 nnoremap n/ n nnoremap N/ N Or in lua:\n1 2 vim.keymap.set(\u0026#39;n\u0026#39;, \u0026#39;n/\u0026#39;, \u0026#39;n\u0026#39;, { noremap = true }) vim.keymap.set(\u0026#39;n\u0026#39;, \u0026#39;N/\u0026#39;, \u0026#39;N\u0026#39;, { noremap = true }) For words we can use nw (next word) and Nw (previous word) which frees up the b key for something else! And also frees up the w key in normal mode for something else.\n1 2 nnoremap nw w nnoremap Nw b Or in lua:\n1 2 vim.keymap.set(\u0026#39;n\u0026#39;, \u0026#39;nw\u0026#39;, \u0026#39;w\u0026#39;, { noremap = true }) vim.keymap.set(\u0026#39;n\u0026#39;, \u0026#39;Nw\u0026#39;, \u0026#39;b\u0026#39;, { noremap = true }) Note: Thank you reddit for your feedback! If remaping one of the main vim key worries you, you can still apply the same ideas to another key combination such as ] and [. So ]w would be next word and [w would be previous word, which frees-up the w and b keys. But personally, I find them too far from the main row to be nice to use.\nWhat about end of word? I like ne for next end \u0026lt;something\u0026gt; and Ne for previous end \u0026lt;something\u0026gt;. This means that next end of word is mapped to new, and previous end of word is mapped to New:\n1 2 nnoremap new e nnoremap New ge Or in lua:\n1 2 vim.keymap.set(\u0026#39;n\u0026#39;, \u0026#39;new\u0026#39;, \u0026#39;e\u0026#39;, { noremap = true }) vim.keymap.set(\u0026#39;n\u0026#39;, \u0026#39;New\u0026#39;, \u0026#39;ge\u0026#39;, { noremap = true }) Now, we could keep going and remap every builtin motion, but we can do better by leveraging the power of advanced textobjects.\nAdvanced textobjects Thanks to treesitter and plugins such as treesitter-textobjects or mini.ai we can define more useful textobjects than words and paragraphs.\nFor instance, using the mini.ai plugin, you can define a function textobject that will match every function in your code file as follows (this is lua code):\n1 2 3 4 5 6 7 ai = require(\u0026#34;mini.ai\u0026#34;) -- ... custom_textobjects = { f = ai.gen_spec.treesitter({ a = \u0026#34;@function.outer\u0026#34;, i = \u0026#34;@function.inner\u0026#34; }) } Using this new textobject, we can:\nSelect inside a function: vif, Select around a function: vaf, Select inside the next function: vinf, Select inside the previous function: vipf. We can also use our new n/N keys to move to the next start of a function (nf), the next end of a function (nef), the previous start of a function (Nf) or the previous end of a function (Nef).\nI have opened a feature request to merge these motions inside mini.ai but for now we can define them ourselves as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 local MiniAi = require(\u0026#34;mini.ai\u0026#34;) -- nf: to next function (around) vim.keymap.set({\u0026#34;n\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;o\u0026#34;}, \u0026#34;nf\u0026#34;, function() return MiniAi.move_cursor(\u0026#34;left\u0026#34;, \u0026#34;a\u0026#34;, k, {search_method=\u0026#34;next\u0026#34;}) end, {silent=true}) -- nef: to end of next function (around) vim.keymap.set({\u0026#34;n\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;o\u0026#34;}, \u0026#34;nef\u0026#34;, function() return MiniAi.move_cursor(\u0026#34;right\u0026#34;, \u0026#34;a\u0026#34;, k, {search_method=\u0026#34;cover_or_next\u0026#34;}) end, {silent=true}) -- nif: to next function (inside) vim.keymap.set({\u0026#34;n\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;o\u0026#34;}, \u0026#34;nif\u0026#34;, function() return MiniAi.move_cursor(\u0026#34;left\u0026#34;, \u0026#34;i\u0026#34;, k, {search_method=\u0026#34;next\u0026#34;}) end, {silent=true}) -- neif: to end of function (inside) vim.keymap.set({\u0026#34;n\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;o\u0026#34;}, \u0026#34;neif\u0026#34;, function() return MiniAi.move_cursor(\u0026#34;right\u0026#34;, \u0026#34;i\u0026#34;, k, {search_method=\u0026#34;cover_or_next\u0026#34;}) end, {silent=true}) -- pf: to prev function (around) vim.keymap.set({\u0026#34;n\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;o\u0026#34;}, \u0026#34;Nf\u0026#34;, function() return MiniAi.move_cursor(\u0026#34;left\u0026#34;, \u0026#34;a\u0026#34;, k, {search_method=\u0026#34;cover_or_prev\u0026#34;}) end, {silent=true}) -- pef: to end of prev function (around) vim.keymap.set({\u0026#34;n\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;o\u0026#34;}, \u0026#34;Nef\u0026#34;, function() return MiniAi.move_cursor(\u0026#34;right\u0026#34;, \u0026#34;a\u0026#34;, k, {search_method=\u0026#34;prev\u0026#34;}) end, {silent=true}) -- pif: to prev function (inside) vim.keymap.set({\u0026#34;n\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;o\u0026#34;}, \u0026#34;Nif\u0026#34;, function() return MiniAi.move_cursor(\u0026#34;left\u0026#34;, \u0026#34;i\u0026#34;, k, {search_method=\u0026#34;cover_or_prev\u0026#34;}) end, {silent=true}) -- peif: to end of prev function (inside) vim.keymap.set({\u0026#34;n\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;o\u0026#34;}, \u0026#34;Neif\u0026#34;, function() return MiniAi.move_cursor(\u0026#34;right\u0026#34;, \u0026#34;i\u0026#34;, k, {search_method=\u0026#34;prev\u0026#34;}) end, {silent=true}) The sky is the limit The only limit is your imagination. There are so many motions that come the in prev/next form that we can free up a lot of space on the keyboard, and reallocate it to our most used verbs or motions.\nHere are some ideas, and leave a comment if you have new ideas!\nNext char: nnoremap nc f and Previous char: nnoremapp Nc F, Go to previous change: nnoremap N. g; and next change: nnoremap n. g,, ","date":"2024-09-20T05:00:00Z","permalink":"https://takia.dev/vim-better-n-n-keys/","title":"Vim: boost the power of the n/N keys!"},{"content":"In vim (and neovim), textobjects and motions are naturally linked, for instance in normal mode w move to the next start of a word, while in operator pending mode w denotes the word object, allowing viw to select inside the word, and vaw to select around the word.\nOther builting objects include p (a paragraph), { (a matching pair of braces) or \u0026quot; (a matching pair of quotes).\nYou can get more information on the builtin textobjects with:\n1 :help text-objects Powerful textobjects More powerful objects can be defined with the mini.ai plugin. This plugin allows using regexes, custom object definitions or even the syntax tree of your programming language to define smart objects. For instance, the following line uses the syntax tree to define a function definition object:\n1 2 3 4 5 custom_textobjects = { f = ai.gen_spec.treesitter({ a = \u0026#34;@function.outer\u0026#34;, i = \u0026#34;@function.outer\u0026#34; }) } This code block defines a new textobject f that selects a function definition: vaf to select around it, and vif to select inside it.\nPowerful motions As of today, mini.ai does not provide a configuration option to define powerful motions to jump to the next/previous text object like w in normal mode would. But we can define these motions ourselves.\nMini.ai does expose a lua function to move the cursor the the next/last start/end of a textobject:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- \u0026#34;left\u0026#34; or \u0026#34;right\u0026#34; local direction = \u0026#34;left\u0026#34; -- \u0026#34;a\u0026#34; for around and \u0026#34;i\u0026#34; for inside local ai = \u0026#34;a\u0026#34; -- the name of your textobject, -- here \u0026#34;f\u0026#34; for function as defined above local k = \u0026#34;f\u0026#34; -- \u0026#34;next\u0026#34;, \u0026#34;cover_or_next\u0026#34;, \u0026#34;prev\u0026#34;, \u0026#34;cover_or_prev\u0026#34; local method = \u0026#34;next\u0026#34; MiniAi.move_cursor(direction, ai, k, {search_method=method} We can leverage this function to define a motion grammar:\nLet\u0026rsquo;s say for instance that we repurpose the keys n and p as our main motion operators:\nn: go to next start p: go to prev start ne: go to next end pe: go to prev end ni: go to next start (inside) pi: go to prev start (inside) First we retain the original behavior of n and p as follows:\nnm: go to next search match pm: go to prev search match We can define the following mappins to move to the next/prev start/end of a function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 -- nf: to next function (around) vim.keymap.set({\u0026#34;n\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;o\u0026#34;}, \u0026#34;nf\u0026#34;, function() return MiniAi.move_cursor(\u0026#34;left\u0026#34;, \u0026#34;a\u0026#34;, k, {search_method=\u0026#34;next\u0026#34;}) end, {silent=true}) -- nef: to end of next function (around) vim.keymap.set({\u0026#34;n\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;o\u0026#34;}, \u0026#34;nef\u0026#34;, function() return MiniAi.move_cursor(\u0026#34;right\u0026#34;, \u0026#34;a\u0026#34;, k, {search_method=\u0026#34;cover_or_next\u0026#34;}) end, {silent=true}) -- nif: to next function (inside) vim.keymap.set({\u0026#34;n\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;o\u0026#34;}, \u0026#34;nif\u0026#34;, function() return MiniAi.move_cursor(\u0026#34;left\u0026#34;, \u0026#34;i\u0026#34;, k, {search_method=\u0026#34;next\u0026#34;}) end, {silent=true}) -- neif: to end of function (inside) vim.keymap.set({\u0026#34;n\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;o\u0026#34;}, \u0026#34;neif\u0026#34;, function() return MiniAi.move_cursor(\u0026#34;right\u0026#34;, \u0026#34;i\u0026#34;, k, {search_method=\u0026#34;cover_or_next\u0026#34;}) end, {silent=true}) -- pf: to prev function (around) vim.keymap.set({\u0026#34;n\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;o\u0026#34;}, \u0026#34;pf\u0026#34;, function() return MiniAi.move_cursor(\u0026#34;left\u0026#34;, \u0026#34;a\u0026#34;, k, {search_method=\u0026#34;cover_or_prev\u0026#34;}) end, {silent=true}) -- pef: to end of prev function (around) vim.keymap.set({\u0026#34;n\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;o\u0026#34;}, \u0026#34;pef\u0026#34;, function() return MiniAi.move_cursor(\u0026#34;right\u0026#34;, \u0026#34;a\u0026#34;, k, {search_method=\u0026#34;prev\u0026#34;}) end, {silent=true}) -- pif: to prev function (inside) vim.keymap.set({\u0026#34;n\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;o\u0026#34;}, \u0026#34;pif\u0026#34;, function() return MiniAi.move_cursor(\u0026#34;left\u0026#34;, \u0026#34;i\u0026#34;, k, {search_method=\u0026#34;cover_or_prev\u0026#34;}) end, {silent=true}) -- peif: to end of prev function (inside) vim.keymap.set({\u0026#34;n\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;o\u0026#34;}, \u0026#34;peif\u0026#34;, function() return MiniAi.move_cursor(\u0026#34;right\u0026#34;, \u0026#34;i\u0026#34;, k, {search_method=\u0026#34;prev\u0026#34;}) end, {silent=true}) I have opened a feature request to merge these motions inside mini.ai.\n","date":"2024-09-20T01:00:00Z","permalink":"https://takia.dev/nvim-better-motions/","title":"Better motions in vim"},{"content":"A common error on Windows 10 and Windows 11 that pops up when attempting to use neotest-golang in neovim is the infamous \u0026ldquo;Test(s) not associated (not found/executed)\u0026rdquo;.\nThis error happens because neotest-golang is unable to read the output of the test command. There are several reasons why neotest-golang might not be able to parse the output of your tests, here are the most common ways to fix it.\nUse gotestsum On windows, you can fix it by changing the test runner to gotestsum as follows:\nFirst, install gotestsum:\n1 go install gotest.tools/gotestsum@latest Then, configure neotest-golang to use the new runner:\n1 2 3 4 5 6 7 require(\u0026#34;neotest\u0026#34;).setup({ adapters = { require(\u0026#34;neotest-golang\u0026#34;)({ runner = \u0026#34;gotestsum\u0026#34; }), }, }) For example, if you are using lazy.nvim plugin manager or the LazyVim distribution, here is how to do it: create a new file in the plugins directory with this content:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 -- file: lua/plugins/neotest-golang.lua return { { \u0026#34;nvim-neotest/neotest\u0026#34;, optional = true, dependencies = { \u0026#34;fredrikaverpil/neotest-golang\u0026#34;, }, opts = { adapters = { [\u0026#34;neotest-golang\u0026#34;] = { -- Here we can set options for neotest-golang, e.g. -- go_test_args = { \u0026#34;-v\u0026#34;, \u0026#34;-race\u0026#34;, \u0026#34;-count=1\u0026#34;, \u0026#34;-timeout=60s\u0026#34; }, dap_go_enabled = true, -- requires leoluz/nvim-dap-go runner = \u0026#34;gotestsum\u0026#34;, go_test_args = { \u0026#34;-v\u0026#34;, \u0026#34;-race\u0026#34;, \u0026#34;-count=1\u0026#34;, -- \u0026#34;-coverprofile=\u0026#34; .. vim.fn.getcwd() .. \u0026#34;/coverage.out\u0026#34;, } }, }, }, }, } The configuration options for gotestsum in neotest-golang is available in this unmerged pull request (as of now at least): documentation.\nSource: relevant issue\nUbuntu: do not use the snaps install On ubuntu, installing GO via snaps cause and output issue when running from nvim which prevents neotest-golang from collecting the test outputs. Instead, download the go tarball and install it from there.\nSource: Relevant issue.\nWindows: Install mingw GCC Neotest-golang by default attempts to run the tests with the flag -race. On windows, you can only run go test -race if you have gcc installed. Thankfully the fix is easy. First, install mingw as follows:\n1 2 # In powershell with admin rights choco install mingw Then make sure that $env:CC is set to gcc by editing your environment variables as shows in the screenshots below.\nAlternatively you can also remove the -race flag from you neotest-golang configuration as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 require(\u0026#34;neotest\u0026#34;).setup({ adapters = { require(\u0026#34;neotest-golang\u0026#34;)({ runner = \u0026#34;gotestsum\u0026#34;, go_test_args = { \u0026#34;-v\u0026#34;, -- \u0026#34;-race\u0026#34;, -- remove the -race flag \u0026#34;-count=1\u0026#34;, } }), }, }) Or, if you use either lazy.nvim or LazyVim create a file in the plugins directory with this content:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 -- file: lua/plugins/neotest-golang.lua return { { \u0026#34;nvim-neotest/neotest\u0026#34;, optional = true, dependencies = { \u0026#34;fredrikaverpil/neotest-golang\u0026#34;, }, opts = { adapters = { [\u0026#34;neotest-golang\u0026#34;] = { runner = \u0026#34;gotestsum\u0026#34;, go_test_args = { \u0026#34;-v\u0026#34;, -- \u0026#34;-race\u0026#34;, -- remove the -race flag \u0026#34;-count=1\u0026#34;, } }, }, }, }, Source: relevant issue.\nSome error outputs Here are some error outputs you might come accross when attempting to solve these errors.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 DEBUG | 2024-09-20T10:12:41Z+0400 | ...cal/nvim-data/lazy/neotest/lua/neotest/lib/file/init.lua:225 | Path separator: \\ INFO | 2024-09-20T10:12:41Z+0400 | ...al/nvim-data/lazy/neotest/lua/neotest/lib/subprocess.lua:33 | Starting child process INFO | 2024-09-20T10:12:41Z+0400 | ...al/nvim-data/lazy/neotest/lua/neotest/lib/subprocess.lua:36 | Parent address: localhost:54013 INFO | 2024-09-20T10:12:41Z+0400 | ...al/nvim-data/lazy/neotest/lua/neotest/lib/subprocess.lua:42 | Starting child process with command: C:\\Program Files\\Neovim\\bin\\nvim.exe --embed --headless -n INFO | 2024-09-20T10:12:41Z+0400 | ...Local/nvim-data/lazy/neotest/lua/neotest/client/init.lua:378 | Initialising client INFO | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:48 | Emitting starting event DEBUG | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener summary for event starting INFO | 2024-09-20T10:12:41Z+0400 | ...cal/nvim-data/lazy/neotest/lua/neotest/adapters/init.lua:18 | Found 1 adapters for directory C:\\Users\\takia.dev\\Documents\\mydocs\\src\\golang\\tutorial\\greetings DEBUG | 2024-09-20T10:12:41Z+0400 | ...cal/nvim-data/lazy/neotest/lua/neotest/adapters/init.lua:19 | Adapters: { { adapter = { build_spec = \u0026lt;function 1\u0026gt;, discover_positions = \u0026lt;function 2\u0026gt;, filter_dir = \u0026lt;function 3\u0026gt;, init = \u0026lt;function 4\u0026gt;, is_test_file = \u0026lt;function 5\u0026gt;, name = \u0026#34;neotest-golang\u0026#34;, results = \u0026lt;function 6\u0026gt;, root = \u0026lt;function 7\u0026gt;, \u0026lt;metatable\u0026gt; = { __call = \u0026lt;function 8\u0026gt; } }, root = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\u0026#34; } } INFO | 2024-09-20T10:12:41Z+0400 | ...Local/nvim-data/lazy/neotest/lua/neotest/client/init.lua:279 | Searching C:\\Users\\takia.dev\\Documents\\mydocs\\src\\golang\\tutorial\\greetings for test files DEBUG | 2024-09-20T10:12:41Z+0400 | ...Local/nvim-data/lazy/neotest/lua/neotest/client/init.lua:295 | Found { { id = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\u0026#34;, name = \u0026#34;greetings\u0026#34;, path = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\u0026#34;, type = \u0026#34;dir\u0026#34; }, { { id = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go\u0026#34;, name = \u0026#34;greetings_test.go\u0026#34;, path = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go\u0026#34;, type = \u0026#34;file\u0026#34; } } } DEBUG | 2024-09-20T10:12:41Z+0400 | ...nvim-data/lazy/neotest/lua/neotest/client/state/init.lua:54 | New positions at ID C:\\Users\\takia.dev\\Documents\\mydocs\\src\\golang\\tutorial\\greetings INFO | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:48 | Emitting discover_positions event DEBUG | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener summary for event discover_positions DEBUG | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener diagnostic for event discover_positions INFO | 2024-09-20T10:12:41Z+0400 | ...Local/nvim-data/lazy/neotest/lua/neotest/client/init.lua:325 | Discovering files with 24 workers DEBUG | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener status for event discover_positions DEBUG | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener state for event discover_positions INFO | 2024-09-20T10:12:41Z+0400 | ...Local/nvim-data/lazy/neotest/lua/neotest/client/init.lua:299 | Parsing C:\\Users\\takia.dev\\Documents\\mydocs\\src\\golang\\tutorial\\greetings\\greetings_test.go DEBUG | 2024-09-20T10:12:41Z+0400 | ...al/nvim-data/lazy/neotest/lua/neotest/lib/subprocess.lua:140 | Waiting for result 1 DEBUG | 2024-09-20T10:12:41Z+0400 | ...al/nvim-data/lazy/neotest/lua/neotest/lib/subprocess.lua:91 | Result registed for callback 1 DEBUG | 2024-09-20T10:12:41Z+0400 | ...Local/nvim-data/lazy/neotest/lua/neotest/client/init.lua:305 | Found { { id = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go\u0026#34;, name = \u0026#34;greetings_test.go\u0026#34;, path = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go\u0026#34;, range = { 0, 0, 22, 0 }, type = \u0026#34;file\u0026#34; }, { { id = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go::TestHelloName\u0026#34;, name = \u0026#34;TestHelloName\u0026#34;, path = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go\u0026#34;, range = { 7, 0, 14, 1 }, type = \u0026#34;test\u0026#34; } }, { { id = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go::TestHelloEmpty\u0026#34;, name = \u0026#34;TestHelloEmpty\u0026#34;, path = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go\u0026#34;, range = { 16, 0, 21, 1 }, type = \u0026#34;test\u0026#34; } } } DEBUG | 2024-09-20T10:12:41Z+0400 | ...nvim-data/lazy/neotest/lua/neotest/client/state/init.lua:54 | New positions at ID C:\\Users\\takia.dev\\Documents\\mydocs\\src\\golang\\tutorial\\greetings\\greetings_test.go INFO | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:48 | Emitting discover_positions event DEBUG | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener summary for event discover_positions DEBUG | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener diagnostic for event discover_positions DEBUG | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener status for event discover_positions DEBUG | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener state for event discover_positions INFO | 2024-09-20T10:12:41Z+0400 | ...Local/nvim-data/lazy/neotest/lua/neotest/client/init.lua:494 | Initialisation finished in 0.03 seconds INFO | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:48 | Emitting test_file_focused event DEBUG | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener summary for event test_file_focused DEBUG | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener diagnostic for event test_file_focused DEBUG | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener status for event test_file_focused INFO | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:48 | Emitting started event DEBUG | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener summary for event started DEBUG | 2024-09-20T10:12:41Z+0400 | ...nvim-data/lazy/neotest/lua/neotest/client/state/init.lua:85 | Setting positions to running C:\\Users\\takia.dev\\Documents\\mydocs\\src\\golang\\tutorial\\greetings\\greetings_test.go INFO | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:48 | Emitting run event DEBUG | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener summary for event run DEBUG | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener diagnostic for event run DEBUG | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener status for event run DEBUG | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener state for event run DEBUG | 2024-09-20T10:12:41Z+0400 | ...-data/lazy/neotest-golang/lua/neotest-golang/logging.lua:47 | [neotest-golang] Searching for go.mod in C:\\Users\\takia.dev\\Documents\\mydocs\\src\\golang\\tutorial\\greetings DEBUG | 2024-09-20T10:12:41Z+0400 | ...-data/lazy/neotest-golang/lua/neotest-golang/logging.lua:47 | [neotest-golang] Found go.mod at C:\\Users\\takia.dev\\Documents\\mydocs\\src\\golang\\tutorial\\greetings\\go.mod DEBUG | 2024-09-20T10:12:41Z+0400 | ...-data/lazy/neotest-golang/lua/neotest-golang/logging.lua:47 | [neotest-golang] Running Go list: go list -json ./... in C:\\Users\\takia.dev\\Documents\\mydocs\\src\\golang\\tutorial\\greetings DEBUG | 2024-09-20T10:12:41Z+0400 | ...-data/lazy/neotest-golang/lua/neotest-golang/logging.lua:47 | [neotest-golang] JSON-decoded \u0026#39;go list\u0026#39; output: { { Deps = { \u0026#34;cmp\u0026#34;, \u0026#34;errors\u0026#34;, \u0026#34;fmt\u0026#34;, \u0026#34;internal/abi\u0026#34;, \u0026#34;internal/asan\u0026#34;, \u0026#34;internal/bisect\u0026#34;, \u0026#34;internal/bytealg\u0026#34;, \u0026#34;internal/byteorder\u0026#34;, \u0026#34;internal/chacha8rand\u0026#34;, \u0026#34;internal/coverage/rtcov\u0026#34;, \u0026#34;internal/cpu\u0026#34;, \u0026#34;internal/filepathlite\u0026#34;, \u0026#34;internal/fmtsort\u0026#34;, \u0026#34;internal/goarch\u0026#34;, \u0026#34;internal/godebug\u0026#34;, \u0026#34;internal/godebugs\u0026#34;, \u0026#34;internal/goexperiment\u0026#34;, \u0026#34;internal/goos\u0026#34;, \u0026#34;internal/itoa\u0026#34;, \u0026#34;internal/msan\u0026#34;, \u0026#34;internal/oserror\u0026#34;, \u0026#34;internal/poll\u0026#34;, \u0026#34;internal/profilerecord\u0026#34;, \u0026#34;internal/race\u0026#34;, \u0026#34;internal/reflectlite\u0026#34;, \u0026#34;internal/runtime/atomic\u0026#34;, \u0026#34;internal/runtime/exithook\u0026#34;, \u0026#34;internal/stringslite\u0026#34;, \u0026#34;internal/syscall/execenv\u0026#34;, \u0026#34;internal/syscall/windows\u0026#34;, \u0026#34;internal/syscall/windows/registry\u0026#34;, \u0026#34;internal/syscall/windows/sysdll\u0026#34;, \u0026#34;internal/testlog\u0026#34;, \u0026#34;internal/unsafeheader\u0026#34;, \u0026#34;io\u0026#34;, \u0026#34;io/fs\u0026#34;, \u0026#34;iter\u0026#34;, \u0026#34;math\u0026#34;, \u0026#34;math/bits\u0026#34;, \u0026#34;math/rand\u0026#34;, \u0026#34;os\u0026#34;, \u0026#34;path\u0026#34;, \u0026#34;reflect\u0026#34;, \u0026#34;runtime\u0026#34;, \u0026#34;runtime/internal/math\u0026#34;, \u0026#34;runtime/internal/sys\u0026#34;, \u0026#34;slices\u0026#34;, \u0026#34;strconv\u0026#34;, \u0026#34;sync\u0026#34;, \u0026#34;sync/atomic\u0026#34;, \u0026#34;syscall\u0026#34;, \u0026#34;time\u0026#34;, \u0026#34;unicode\u0026#34;, \u0026#34;unicode/utf16\u0026#34;, \u0026#34;unicode/utf8\u0026#34;, \u0026#34;unsafe\u0026#34; }, Dir = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\u0026#34;, GoFiles = { \u0026#34;greetings.go\u0026#34; }, ImportPath = \u0026#34;takia.dev/greetings\u0026#34;, Imports = { \u0026#34;errors\u0026#34;, \u0026#34;fmt\u0026#34;, \u0026#34;math/rand\u0026#34; }, Match = { \u0026#34;./...\u0026#34; }, Module = { Dir = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\u0026#34;, GoMod = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\go.mod\u0026#34;, GoVersion = \u0026#34;1.23.0\u0026#34;, Main = true, Path = \u0026#34;takia.dev/greetings\u0026#34; }, Name = \u0026#34;greetings\u0026#34;, Root = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\u0026#34;, Stale = true, StaleReason = \u0026#34;build ID mismatch\u0026#34;, TestGoFiles = { \u0026#34;greetings_test.go\u0026#34; }, TestImports = { \u0026#34;regexp\u0026#34;, \u0026#34;testing\u0026#34; } } } INFO | 2024-09-20T10:12:41Z+0400 | ...-data/lazy/neotest-golang/lua/neotest-golang/logging.lua:59 | [neotest-golang] Test command: gotestsum --jsonfile=C:/Users/takia.dev/AppData/Local/Temp/nvim.0/Ajb5cu/1 --format=standard-verbose -- -v -race -count=1 takia.dev/greetings -run ^(^TestHelloName$|^TestHelloEmpty$)$ DEBUG | 2024-09-20T10:12:41Z+0400 | ...-data/lazy/neotest-golang/lua/neotest-golang/logging.lua:47 | [neotest-golang] RunSpec: { command = { \u0026#34;gotestsum\u0026#34;, \u0026#34;--jsonfile=C:/Users/takia.dev/AppData/Local/Temp/nvim.0/Ajb5cu/1\u0026#34;, \u0026#34;--format=standard-verbose\u0026#34;, \u0026#34;--\u0026#34;, \u0026#34;-v\u0026#34;, \u0026#34;-race\u0026#34;, \u0026#34;-count=1\u0026#34;, \u0026#34;takia.dev/greetings\u0026#34;, \u0026#34;-run\u0026#34;, \u0026#34;^(^TestHelloName$|^TestHelloEmpty$)$\u0026#34; }, context = { golist_data = { { Deps = { \u0026#34;cmp\u0026#34;, \u0026#34;errors\u0026#34;, \u0026#34;fmt\u0026#34;, \u0026#34;internal/abi\u0026#34;, \u0026#34;internal/asan\u0026#34;, \u0026#34;internal/bisect\u0026#34;, \u0026#34;internal/bytealg\u0026#34;, \u0026#34;internal/byteorder\u0026#34;, \u0026#34;internal/chacha8rand\u0026#34;, \u0026#34;internal/coverage/rtcov\u0026#34;, \u0026#34;internal/cpu\u0026#34;, \u0026#34;internal/filepathlite\u0026#34;, \u0026#34;internal/fmtsort\u0026#34;, \u0026#34;internal/goarch\u0026#34;, \u0026#34;internal/godebug\u0026#34;, \u0026#34;internal/godebugs\u0026#34;, \u0026#34;internal/goexperiment\u0026#34;, \u0026#34;internal/goos\u0026#34;, \u0026#34;internal/itoa\u0026#34;, \u0026#34;internal/msan\u0026#34;, \u0026#34;internal/oserror\u0026#34;, \u0026#34;internal/poll\u0026#34;, \u0026#34;internal/profilerecord\u0026#34;, \u0026#34;internal/race\u0026#34;, \u0026#34;internal/reflectlite\u0026#34;, \u0026#34;internal/runtime/atomic\u0026#34;, \u0026#34;internal/runtime/exithook\u0026#34;, \u0026#34;internal/stringslite\u0026#34;, \u0026#34;internal/syscall/execenv\u0026#34;, \u0026#34;internal/syscall/windows\u0026#34;, \u0026#34;internal/syscall/windows/registry\u0026#34;, \u0026#34;internal/syscall/windows/sysdll\u0026#34;, \u0026#34;internal/testlog\u0026#34;, \u0026#34;internal/unsafeheader\u0026#34;, \u0026#34;io\u0026#34;, \u0026#34;io/fs\u0026#34;, \u0026#34;iter\u0026#34;, \u0026#34;math\u0026#34;, \u0026#34;math/bits\u0026#34;, \u0026#34;math/rand\u0026#34;, \u0026#34;os\u0026#34;, \u0026#34;path\u0026#34;, \u0026#34;reflect\u0026#34;, \u0026#34;runtime\u0026#34;, \u0026#34;runtime/internal/math\u0026#34;, \u0026#34;runtime/internal/sys\u0026#34;, \u0026#34;slices\u0026#34;, \u0026#34;strconv\u0026#34;, \u0026#34;sync\u0026#34;, \u0026#34;sync/atomic\u0026#34;, \u0026#34;syscall\u0026#34;, \u0026#34;time\u0026#34;, \u0026#34;unicode\u0026#34;, \u0026#34;unicode/utf16\u0026#34;, \u0026#34;unicode/utf8\u0026#34;, \u0026#34;unsafe\u0026#34; }, Dir = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\u0026#34;, GoFiles = { \u0026#34;greetings.go\u0026#34; }, ImportPath = \u0026#34;takia.dev/greetings\u0026#34;, Imports = { \u0026#34;errors\u0026#34;, \u0026#34;fmt\u0026#34;, \u0026#34;math/rand\u0026#34; }, Match = { \u0026#34;./...\u0026#34; }, Module = { Dir = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\u0026#34;, GoMod = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\go.mod\u0026#34;, GoVersion = \u0026#34;1.23.0\u0026#34;, Main = true, Path = \u0026#34;takia.dev/greetings\u0026#34; }, Name = \u0026#34;greetings\u0026#34;, Root = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\u0026#34;, Stale = true, StaleReason = \u0026#34;build ID mismatch\u0026#34;, TestGoFiles = { \u0026#34;greetings_test.go\u0026#34; }, TestImports = { \u0026#34;regexp\u0026#34;, \u0026#34;testing\u0026#34; } } }, pos_id = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go\u0026#34;, test_output_json_filepath = \u0026#34;C:/Users/takia.dev/AppData/Local/Temp/nvim.0/Ajb5cu/1\u0026#34; }, cwd = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\u0026#34; } INFO | 2024-09-20T10:12:41Z+0400 | ...data/lazy/neotest/lua/neotest/client/strategies/init.lua:36 | Starting process neotest-golang:C:\\Users\\takia.dev\\Documents\\mydocs\\src\\golang\\tutorial\\greetings-C:\\Users\\takia.dev\\Documents\\mydocs\\src\\golang\\tutorial\\greetings\\greetings_test.go with strategy integrated DEBUG | 2024-09-20T10:12:41Z+0400 | ...data/lazy/neotest/lua/neotest/client/strategies/init.lua:37 | Strategy spec { command = { \u0026#34;gotestsum\u0026#34;, \u0026#34;--jsonfile=C:/Users/takia.dev/AppData/Local/Temp/nvim.0/Ajb5cu/1\u0026#34;, \u0026#34;--format=standard-verbose\u0026#34;, \u0026#34;--\u0026#34;, \u0026#34;-v\u0026#34;, \u0026#34;-race\u0026#34;, \u0026#34;-count=1\u0026#34;, \u0026#34;takia.dev/greetings\u0026#34;, \u0026#34;-run\u0026#34;, \u0026#34;^(^TestHelloName$|^TestHelloEmpty$)$\u0026#34; }, context = { golist_data = { { Deps = { \u0026#34;cmp\u0026#34;, \u0026#34;errors\u0026#34;, \u0026#34;fmt\u0026#34;, \u0026#34;internal/abi\u0026#34;, \u0026#34;internal/asan\u0026#34;, \u0026#34;internal/bisect\u0026#34;, \u0026#34;internal/bytealg\u0026#34;, \u0026#34;internal/byteorder\u0026#34;, \u0026#34;internal/chacha8rand\u0026#34;, \u0026#34;internal/coverage/rtcov\u0026#34;, \u0026#34;internal/cpu\u0026#34;, \u0026#34;internal/filepathlite\u0026#34;, \u0026#34;internal/fmtsort\u0026#34;, \u0026#34;internal/goarch\u0026#34;, \u0026#34;internal/godebug\u0026#34;, \u0026#34;internal/godebugs\u0026#34;, \u0026#34;internal/goexperiment\u0026#34;, \u0026#34;internal/goos\u0026#34;, \u0026#34;internal/itoa\u0026#34;, \u0026#34;internal/msan\u0026#34;, \u0026#34;internal/oserror\u0026#34;, \u0026#34;internal/poll\u0026#34;, \u0026#34;internal/profilerecord\u0026#34;, \u0026#34;internal/race\u0026#34;, \u0026#34;internal/reflectlite\u0026#34;, \u0026#34;internal/runtime/atomic\u0026#34;, \u0026#34;internal/runtime/exithook\u0026#34;, \u0026#34;internal/stringslite\u0026#34;, \u0026#34;internal/syscall/execenv\u0026#34;, \u0026#34;internal/syscall/windows\u0026#34;, \u0026#34;internal/syscall/windows/registry\u0026#34;, \u0026#34;internal/syscall/windows/sysdll\u0026#34;, \u0026#34;internal/testlog\u0026#34;, \u0026#34;internal/unsafeheader\u0026#34;, \u0026#34;io\u0026#34;, \u0026#34;io/fs\u0026#34;, \u0026#34;iter\u0026#34;, \u0026#34;math\u0026#34;, \u0026#34;math/bits\u0026#34;, \u0026#34;math/rand\u0026#34;, \u0026#34;os\u0026#34;, \u0026#34;path\u0026#34;, \u0026#34;reflect\u0026#34;, \u0026#34;runtime\u0026#34;, \u0026#34;runtime/internal/math\u0026#34;, \u0026#34;runtime/internal/sys\u0026#34;, \u0026#34;slices\u0026#34;, \u0026#34;strconv\u0026#34;, \u0026#34;sync\u0026#34;, \u0026#34;sync/atomic\u0026#34;, \u0026#34;syscall\u0026#34;, \u0026#34;time\u0026#34;, \u0026#34;unicode\u0026#34;, \u0026#34;unicode/utf16\u0026#34;, \u0026#34;unicode/utf8\u0026#34;, \u0026#34;unsafe\u0026#34; }, Dir = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\u0026#34;, GoFiles = { \u0026#34;greetings.go\u0026#34; }, ImportPath = \u0026#34;takia.dev/greetings\u0026#34;, Imports = { \u0026#34;errors\u0026#34;, \u0026#34;fmt\u0026#34;, \u0026#34;math/rand\u0026#34; }, Match = { \u0026#34;./...\u0026#34; }, Module = { Dir = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\u0026#34;, GoMod = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\go.mod\u0026#34;, GoVersion = \u0026#34;1.23.0\u0026#34;, Main = true, Path = \u0026#34;takia.dev/greetings\u0026#34; }, Name = \u0026#34;greetings\u0026#34;, Root = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\u0026#34;, Stale = true, StaleReason = \u0026#34;build ID mismatch\u0026#34;, TestGoFiles = { \u0026#34;greetings_test.go\u0026#34; }, TestImports = { \u0026#34;regexp\u0026#34;, \u0026#34;testing\u0026#34; } } }, pos_id = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go\u0026#34;, test_output_json_filepath = \u0026#34;C:/Users/takia.dev/AppData/Local/Temp/nvim.0/Ajb5cu/1\u0026#34; }, cwd = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\u0026#34;, strategy = { height = 40, width = 120 } } INFO | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:48 | Emitting test_focused event DEBUG | 2024-09-20T10:12:41Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener summary for event test_focused INFO | 2024-09-20T10:12:42Z+0400 | ...data/lazy/neotest/lua/neotest/client/strategies/init.lua:56 | Process for position neotest-golang:C:\\Users\\takia.dev\\Documents\\mydocs\\src\\golang\\tutorial\\greetings-C:\\Users\\takia.dev\\Documents\\mydocs\\src\\golang\\tutorial\\greetings\\greetings_test.go exited with code 1 DEBUG | 2024-09-20T10:12:42Z+0400 | ...data/lazy/neotest/lua/neotest/client/strategies/init.lua:58 | Output of process C:\\Users\\takia.dev\\AppData\\Local\\Temp\\nvim.0\\Ajb5cu\\2 DEBUG | 2024-09-20T10:12:42Z+0400 | ...-data/lazy/neotest-golang/lua/neotest-golang/logging.lua:47 | [neotest-golang] Raw \u0026#39;go test\u0026#39; output: { \u0026#39;{\u0026#34;Time\u0026#34;:\u0026#34;2024-09-20T10:12:42.738978+04:00\u0026#34;,\u0026#34;Action\u0026#34;:\u0026#34;start\u0026#34;,\u0026#34;Package\u0026#34;:\u0026#34;takia.dev/greetings\u0026#34;}\u0026#39;, \u0026#39;{\u0026#34;Time\u0026#34;:\u0026#34;2024-09-20T10:12:42.738978+04:00\u0026#34;,\u0026#34;Action\u0026#34;:\u0026#34;output\u0026#34;,\u0026#34;Package\u0026#34;:\u0026#34;takia.dev/greetings\u0026#34;,\u0026#34;Output\u0026#34;:\u0026#34;FAIL\\\\ttakia.dev/greetings [build failed]\\\\n\u0026#34;}\u0026#39;, \u0026#39;{\u0026#34;Time\u0026#34;:\u0026#34;2024-09-20T10:12:42.738978+04:00\u0026#34;,\u0026#34;Action\u0026#34;:\u0026#34;fail\u0026#34;,\u0026#34;Package\u0026#34;:\u0026#34;takia.dev/greetings\u0026#34;,\u0026#34;Elapsed\u0026#34;:0}\u0026#39; } DEBUG | 2024-09-20T10:12:42Z+0400 | ...-data/lazy/neotest-golang/lua/neotest-golang/logging.lua:47 | [neotest-golang] Final internal test result data { [\u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go::TestHelloEmpty\u0026#34;] = { duplicate_test_detected = false, errors = {}, gotest_data = { name = \u0026#34;\u0026#34;, output = {}, pkg = \u0026#34;\u0026#34; }, neotest_data = { id = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go::TestHelloEmpty\u0026#34;, name = \u0026#34;TestHelloEmpty\u0026#34;, path = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go\u0026#34;, range = { 16, 0, 21, 1 }, type = \u0026#34;test\u0026#34; }, status = \u0026#34;skipped\u0026#34; }, [\u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go::TestHelloName\u0026#34;] = { duplicate_test_detected = false, errors = {}, gotest_data = { name = \u0026#34;\u0026#34;, output = {}, pkg = \u0026#34;\u0026#34; }, neotest_data = { id = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go::TestHelloName\u0026#34;, name = \u0026#34;TestHelloName\u0026#34;, path = \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go\u0026#34;, range = { 7, 0, 14, 1 }, type = \u0026#34;test\u0026#34; }, status = \u0026#34;skipped\u0026#34; } } WARN | 2024-09-20T10:12:42Z+0400 | ...-data/lazy/neotest-golang/lua/neotest-golang/logging.lua:69 | [neotest-golang] Test(s) not associated (not found/executed): { \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go::TestHelloEmpty\u0026#34;, \u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go::TestHelloName\u0026#34; } DEBUG | 2024-09-20T10:12:42Z+0400 | ...-data/lazy/neotest-golang/lua/neotest-golang/logging.lua:47 | [neotest-golang] Final Neotest result data { [\u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go\u0026#34;] = { output = \u0026#34;C:/Users/takia.dev/AppData/Local/Temp/nvim.0/Ajb5cu/5\u0026#34;, status = \u0026#34;failed\u0026#34; }, [\u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go::TestHelloEmpty\u0026#34;] = { errors = {}, output = \u0026#34;C:/Users/takia.dev/AppData/Local/Temp/nvim.0/Ajb5cu/3\u0026#34;, status = \u0026#34;skipped\u0026#34; }, [\u0026#34;C:\\\\Users\\\\takia.dev\\\\Documents\\\\mydocs\\\\src\\\\golang\\\\tutorial\\\\greetings\\\\greetings_test.go::TestHelloName\u0026#34;] = { errors = {}, output = \u0026#34;C:/Users/takia.dev/AppData/Local/Temp/nvim.0/Ajb5cu/4\u0026#34;, status = \u0026#34;skipped\u0026#34; } } DEBUG | 2024-09-20T10:12:42Z+0400 | ...nvim-data/lazy/neotest/lua/neotest/client/state/init.lua:70 | New results for adapter neotest-golang:C:\\Users\\takia.dev\\Documents\\mydocs\\src\\golang\\tutorial\\greetings INFO | 2024-09-20T10:12:42Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:48 | Emitting results event DEBUG | 2024-09-20T10:12:42Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener status for event results DEBUG | 2024-09-20T10:12:42Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener output for event results DEBUG | 2024-09-20T10:12:42Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener state for event results DEBUG | 2024-09-20T10:12:42Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener output_panel for event results DEBUG | 2024-09-20T10:12:42Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener summary for event results DEBUG | 2024-09-20T10:12:42Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener diagnostic for event results DEBUG | 2024-09-20T10:12:42Z+0400 | ...m-data/lazy/neotest/lua/neotest/consumers/diagnostic.lua:55 | Setting diagnostics for C:\\Users\\takia.dev\\Documents\\mydocs\\src\\golang\\tutorial\\greetings\\greetings_test.go {} DEBUG | 2024-09-20T10:12:42Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener trouble for event results DEBUG | 2024-09-20T10:12:42Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener quickfix for event results DEBUG | 2024-09-20T10:12:42Z+0400 | ...nvim-data/lazy/neotest/lua/neotest/client/state/init.lua:70 | New results for adapter neotest-golang:C:\\Users\\takia.dev\\Documents\\mydocs\\src\\golang\\tutorial\\greetings INFO | 2024-09-20T10:12:42Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:48 | Emitting results event DEBUG | 2024-09-20T10:12:42Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener status for event results DEBUG | 2024-09-20T10:12:42Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener output for event results DEBUG | 2024-09-20T10:12:42Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener state for event results DEBUG | 2024-09-20T10:12:42Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener output_panel for event results DEBUG | 2024-09-20T10:12:43Z+0400 | ...cal/nvim-data/lazy/neotest/lua/neotest/lib/file/init.lua:23 | Reading file: C:/Users/takia.dev/AppData/Local/Temp/nvim.0/Ajb5cu/3 DEBUG | 2024-09-20T10:12:43Z+0400 | ...cal/nvim-data/lazy/neotest/lua/neotest/lib/file/init.lua:23 | Reading file: C:/Users/takia.dev/AppData/Local/Temp/nvim.0/Ajb5cu/4 DEBUG | 2024-09-20T10:12:43Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener summary for event results DEBUG | 2024-09-20T10:12:43Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener diagnostic for event results DEBUG | 2024-09-20T10:12:43Z+0400 | ...m-data/lazy/neotest/lua/neotest/consumers/diagnostic.lua:55 | Setting diagnostics for C:\\Users\\takia.dev\\Documents\\mydocs\\src\\golang\\tutorial\\greetings\\greetings_test.go {} DEBUG | 2024-09-20T10:12:43Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener trouble for event results DEBUG | 2024-09-20T10:12:43Z+0400 | ...vim-data/lazy/neotest/lua/neotest/client/events/init.lua:50 | Calling listener quickfix for event results which is due to the same error as when running go test -race:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 go test -json -race # takia.dev/greetings.test C:\\Program Files\\Go\\pkg\\tool\\windows_amd64\\link.exe: running clang failed: exit status 1104 C:\\Program Files (x86)\\Microsoft Visual Studio\\2022\\BuildTools\\VC\\Tools\\Llvm\\x64\\bin\\clang.exe -m64 -s -mconsole -Wl,--tsaware -Wl,--nxcompat -Wl,--major-os-version=6 -Wl,--minor-os-version=1 -Wl,--major-subsystem-version=6 -Wl,--minor-subsystem-version=1 -o $WORK\\b001\\greetings.test.exe -Qunused-arguments C:\\Users\\takia.dev\\AppData\\Local\\Temp\\go-link-2753284183\\go.o C:\\Users\\takia.dev\\AppData\\Local\\Temp\\go-link-2753284183\\000000.o C:\\Users\\takia.dev\\AppData\\Local\\Temp\\go-link-2753284183\\000001.o C:\\Users\\takia.dev\\AppData\\Local\\Temp\\go-link-2753284183\\000002.o C:\\Users\\takia.dev\\AppData\\Local\\Temp\\go-link-2753284183\\000003.o C:\\Users\\takia.dev\\AppData\\Local\\Temp\\go-link-2753284183\\000004.o C:\\Users\\takia.dev\\AppData\\Local\\Temp\\go-link-2753284183\\000005.o C:\\Users\\takia.dev\\AppData\\Local\\Temp\\go-link-2753284183\\000006.o C:\\Users\\takia.dev\\AppData\\Local\\Temp\\go-link-2753284183\\000007.o C:\\Users\\takia.dev\\AppData\\Local\\Temp\\go-link-2753284183\\000008.o C:\\Users\\takia.dev\\AppData\\Local\\Temp\\go-link-2753284183\\000009.o C:\\Users\\takia.dev\\AppData\\Local\\Temp\\go-link-2753284183\\000010.o -O2 -g -O2 -g -no-pie -Wl,-T,C:\\Users\\takia.dev\\AppData\\Local\\Temp\\go-link-2753284183\\fix_debug_gdb_scripts.ld -Wl,--start-group -lmingwex -lmingw32 -Wl,--end-group -lkernel32 LINK : warning LNK4044: unrecognized option \u0026#39;/-tsaware\u0026#39;; ignored LINK : warning LNK4044: unrecognized option \u0026#39;/-nxcompat\u0026#39;; ignored LINK : warning LNK4044: unrecognized option \u0026#39;/-major-os-version=6\u0026#39;; ignored LINK : warning LNK4044: unrecognized option \u0026#39;/-minor-os-version=1\u0026#39;; ignored LINK : warning LNK4044: unrecognized option \u0026#39;/-major-subsystem-version=6\u0026#39;; ignored LINK : warning LNK4044: unrecognized option \u0026#39;/-minor-subsystem-version=1\u0026#39;; ignored LINK : warning LNK4044: unrecognized option \u0026#39;/T\u0026#39;; ignored LINK : warning LNK4044: unrecognized option \u0026#39;/-start-group\u0026#39;; ignored LINK : warning LNK4044: unrecognized option \u0026#39;/-end-group\u0026#39;; ignored LINK : fatal error LNK1104: cannot open file \u0026#39;mingwex.lib\u0026#39; clang: error: linker command failed with exit code 1104 (use -v to see invocation) {\u0026#34;Time\u0026#34;:\u0026#34;2024-09-20T10:32:59.8864019+04:00\u0026#34;,\u0026#34;Action\u0026#34;:\u0026#34;start\u0026#34;,\u0026#34;Package\u0026#34;:\u0026#34;takia.dev/greetings\u0026#34;} {\u0026#34;Time\u0026#34;:\u0026#34;2024-09-20T10:32:59.8864019+04:00\u0026#34;,\u0026#34;Action\u0026#34;:\u0026#34;output\u0026#34;,\u0026#34;Package\u0026#34;:\u0026#34;takia.dev/greetings\u0026#34;,\u0026#34;Output\u0026#34;:\u0026#34;FAIL\\ttakia.dev/greetings [build failed]\\n\u0026#34;} {\u0026#34;Time\u0026#34;:\u0026#34;2024-09-20T10:32:59.8869511+04:00\u0026#34;,\u0026#34;Action\u0026#34;:\u0026#34;fail\u0026#34;,\u0026#34;Package\u0026#34;:\u0026#34;takia.dev/greetings\u0026#34;,\u0026#34;Elapsed\u0026#34;:0.001} ","date":"2024-09-19T00:00:00Z","permalink":"https://takia.dev/neotest-golang-issues/","title":"Neotest-Golang: Solving Test(s) not associated issue"},{"content":"It was a real hassle to get nvim-treesitter to work on Windows 11. Here is how I got it working. - A working installation guide in 2024.\nDependencies The neovim treesitter plugin requires a working C/C++ compiler to install new language support. Even though the github documentation explains how to install several C/C++ compilers, only one worked for me: clang compiler installed through the Build Tools for Visual Studio 2022. Installing clang from the LLVM app did not link properly and using the cl compiler from the Build Tools did not work either.\nFirst, download the Build Tools for Visual Studio\nIn the installation windows, be sure to check Desktop development with C++ on the left and C++ clang tools for Windows on the right as show in the picture below.\nVisual Studio Build Tools InstallerThen, update the system environment variables and set CC = clang.\nSetup steps To avoid parsers conflicts, rename the following folder:\n1 C:\\Program Files\\Neovim\\lib\\nvim\\parser To something else, for instance:\n1 C:\\Program Files\\Neovim\\lib\\nvim\\parser.sav Configure the terminal To be able to compile the treesiter parsers, you need a working developper terminal. Here is how to configure powershell.\nFirst, open or create the powershell user-profile file:\n1 notepad.exe $HOME\\Documents\\PowerShell\\Profile.ps1 And paste this code (related stackoverflow thread) inside:\n1 2 3 4 5 6 7 8 $vsPath = \u0026amp;\u0026#34;${env:ProgramFiles(x86)}\\Microsoft Visual Studio\\Installer\\vswhere.exe\u0026#34; -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationpath Write-Host \u0026#34;Microsoft Visual Studio path = \u0026#39;$vsPath\u0026#39;\u0026#34; # Use module `Microsoft.VisualStudio.DevShell.dll` Import-Module (Get-ChildItem $vsPath -Recurse -File -Filter Microsoft.VisualStudio.DevShell.dll).FullName Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments \u0026#39;-arch=x64\u0026#39; Finally, restart your terminal and make sure you are running 64 bit powershell as follows:\n1 [Environment]::Is64BitProcess This should respond true. If it doesn\u0026rsquo;t look for the 64bit powershell executable on your machine.\nInstall nvim-treesitter Finally, install nvim-treesitter using you favorite package manager. The nvim-treesitter github has some installation instructions. Here is my init.lua file:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 require(\u0026#39;pckr\u0026#39;).add{ {\u0026#39;nvim-treesitter/nvim-treesitter\u0026#39;, tag = \u0026#34;v0.9.2\u0026#34;, run = function() require (\u0026#39;nvim-treesitter.install\u0026#39;).compilers = { \u0026#34;clang\u0026#34; } local ts_update = require(\u0026#39;nvim-treesitter.install\u0026#39;).update({ with_sync = true }) ts_update() end, config = function () require (\u0026#39;nvim-treesitter.install\u0026#39;).compilers = { \u0026#34;clang\u0026#34; } local configs = require(\u0026#34;nvim-treesitter.configs\u0026#34;) configs.setup({ ensure_installed = { \u0026#34;go\u0026#34;, \u0026#34;gomod\u0026#34;, \u0026#34;python\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;lua\u0026#34;, \u0026#34;vim\u0026#34;, \u0026#34;vimdoc\u0026#34;, \u0026#34;query\u0026#34;, \u0026#34;markdown\u0026#34;, \u0026#34;markdown_inline\u0026#34;}, sync_install = false, highlight = { enable = true }, indent = { enable = false }, -- Enable vim-matchup plugin integration with treesitter matchup = { enable = true, include_match_words = true, -- disable = { \u0026#34;c\u0026#34;, \u0026#34;ruby\u0026#34; }, -- [options] }, }) end, }; } Hopefully, you can get it up and running too. Happy coding!\n","date":"2024-09-06T01:00:00Z","permalink":"https://takia.dev/nvim-treesitter-windows-11/","title":"How to install neovim treesitter on Windows 11"},{"content":"In this article, we will solve the following programming exercise in GO:\nCall 3 Webservices asynchronously using go routines\nHere are the services:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type Input struct{} type A_Output struct{} type B_Output struct{} type C_Output struct{} func ServiceA(i Input) (A_Output, error) { // simulate a real service call \u0026lt;-time.After(30 * time.Millisecond) return A_Output{}, nil } func ServiceB(i Input) (B_Output, error) { // simulate a real service call \u0026lt;-time.After(1 * time.Millisecond) return B_Output{}, nil } func ServiceC(a A_Output, b B_Output) (C_Output, error) { // simulate a real service call \u0026lt;-time.After(10 * time.Millisecond) return C_Output{}, errors.New(\u0026#34;ERROR C\u0026#34;) } Dependency analysis The first step is to analyze dependencies to identify which service can run concurrently. Since A and B are independent from each other, they can be called at the same time. Service C, on the other, depends on both the output of A and B and therefore has to be called after they have run. This is summarized in the figure below.\nDependencies between servicesVideo Solution The full video walkthrough is available on youtube:\nFull Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 package main import ( \u0026#34;context\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) type Input struct{} type A_Output struct{} type B_Output struct{} type C_Output struct{} func ServiceA(i Input) (A_Output, error) { // simulate a real service call println(\u0026#34;ServiceA is running\u0026#34;) \u0026lt;-time.After(30 * time.Millisecond) println(\u0026#34;ServiceA is done\u0026#34;) return A_Output{}, nil } func ServiceB(i Input) (B_Output, error) { // simulate a real service call println(\u0026#34;ServiceB is running\u0026#34;) \u0026lt;-time.After(1 * time.Millisecond) println(\u0026#34;ServiceB is done\u0026#34;) return B_Output{}, nil } func ServiceC(a A_Output, b B_Output) (C_Output, error) { // simulate a real service call println(\u0026#34;ServiceC is running\u0026#34;) \u0026lt;-time.After(10 * time.Millisecond) println(\u0026#34;ServiceC is done\u0026#34;) return C_Output{}, errors.New(\u0026#34;ERROR C\u0026#34;) } func CallServices(i Input, timeout time.Duration) (C_Output, error) { ctx, cancel := context.WithTimeout( context.Background(), timeout, ) defer cancel() a_out := make(chan A_Output, 1) e_out := make(chan error, 2) go func() { defer close(a_out) a, ok := ServiceA(i) if ok != nil { e_out \u0026lt;- ok println(\u0026#34;Got an error from serviceA\u0026#34;) return } a_out \u0026lt;- a }() b_out := make(chan B_Output, 1) go func() { defer close(b_out) b, ok := ServiceB(i) if ok != nil { e_out \u0026lt;- ok println(\u0026#34;Got an error from serviceB\u0026#34;) return } b_out \u0026lt;- b }() var a A_Output var b B_Output for _ = range 2 { select { case a = \u0026lt;-a_out: println(\u0026#34;Received value from a_out channel\u0026#34;) a_out = nil case b = \u0026lt;-b_out: println(\u0026#34;Received value from b_out channel\u0026#34;) b_out = nil case \u0026lt;-e_out: println(\u0026#34;Received error from e_out (ServiceA or ServiceB)\u0026#34;) return C_Output{}, errors.New(\u0026#34;ERROR\u0026#34;) case \u0026lt;-ctx.Done(): println(\u0026#34;Received Timeout (ServiceA or ServiceB)\u0026#34;) return C_Output{}, errors.New(\u0026#34;TIMEOUT\u0026#34;) } } c_out := make(chan C_Output, 1) go func() { defer close(c_out) c, ok := ServiceC(a, b) if ok != nil { e_out \u0026lt;- ok println(\u0026#34;Got an error from serviceC\u0026#34;) return } c_out \u0026lt;- c }() var c C_Output select { case c = \u0026lt;-c_out: println(\u0026#34;Received value from c_out channel\u0026#34;) case \u0026lt;-e_out: println(\u0026#34;Received error from e_out channel (ServiceC)\u0026#34;) return C_Output{}, errors.New(\u0026#34;ERROR from C\u0026#34;) case \u0026lt;-ctx.Done(): println(\u0026#34;Received Timeout from context (ServiceC)\u0026#34;) return C_Output{}, errors.New(\u0026#34;Timeout ServiceC\u0026#34;) } return c, nil } func main() { i := Input{} c, ok := CallServices(i, 50*time.Millisecond) if ok != nil { println(\u0026#34;There was an error:\u0026#34;, ok.Error()) return } fmt.Printf(\u0026#34;All Done! %v\u0026#34;, c) } ","date":"2024-09-01T00:00:00Z","permalink":"https://takia.dev/go-exercise-goroutines-1/","title":"Using goroutines to call 3 webservices in Go"},{"content":"In the Go progamming language, slices are one of the most basic and fundamental data structures. And yet, slices often exhibit strange behaviors: when a slice is passed as argument to a function, some – but not all – of its data can be modified by the function. In this article, we aim for an in-depth understanding of slices and their behavior by looking at how they are implemented under the hood and how the memory behaves when performing common slice operations.\nWhat are slices? A bird\u0026rsquo;s view At first glance, slices are Go\u0026rsquo;s equivalent for the vector type in C++ or ArrayList in Java. A slice is a dynamic array: it\u0026rsquo;s a container that stores a sequence of elements indexed by integers starting from 0. The elements are stored contiguously in memory. Unlike Go arrays, slices can be resized. In the following code snippet, we illustrate common operations on slices:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Create a slice of `rune` with initial length var length = 5 var s = make([]rune, length) // Access the existing elements in the slice for i := 0; i \u0026lt; length; i++ { s[i] = \u0026#39;A\u0026#39; } // Append a new element to the slice s = append(s, \u0026#39;B\u0026#39;) // print the new length of the slice println(len(s)) // 6 How are slices implemented? Under the hood, slices are implemented as a struct with three variables: a pointer to the data array, the length of the slice and the capacity of the slice. In this section, we will use valid Go code to shed light on this hidden implementation.\nFor instance, the following diagram illustrates the memory layout of a slice s with length 5 and capacity 7. The elements of s are {1, 2, 3, 4, 5}, they are stored contiguously at memory location 0xe830.\nMemory layout of a slice with length 5 and capacity 7Because the slice object only contains a pointer to the data array and not the array itself, the actual size of the array does not impact the size of the slice object. For instance, in the code below we create two slices, one with 0 elements and one with 5 elements, but Sizeof shows that the size of the slice objects is 24 bytes either way.\n1 2 3 4 var s0 = []int{} var s1 = []int{1, 2, 3, 4, 5} println(unsafe.Sizeof(s0)) // 24 bytes println(unsafe.Sizeof(s1)) // 24 bytes What happens when an element is added to a slice? Since the elements of a slice are stored contiguously in memory, it can happen that there is not enough space at the end of the slice to add a new element. In this case, a new memory location with more space is allocated to the slice and the elements are copied to the new location. Go keeps track of how much space is reserved for the slice through the capacity value and will roughly double the capacity every time the slice is reallocated.\nThe slideshow below illustrates what happens in memory when we append elements to a slice. Use the buttons to move to the next codeline.\nprev next prev next Revealing the underlying struct implementation We can use pointer tricks to force the compiler to reveal this hidden struct by reinterpreting the memory address as a struct pointer. This is what the reinterpretAsStruct function does in the code below:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) type SliceStruct struct { array *[100]int length int capacity int } func reinterpretAsStruct(sliceObject []int) SliceStruct { var pointerToSlice = unsafe.Pointer(\u0026amp;sliceObject) var pointerToStruct = (*SliceStruct)(pointerToSlice) var structObject SliceStruct = *pointerToStruct return structObject } func main() { var s []int = make([]int, 3, 15) var struct1 SliceStruct = reinterpretAsStruct(s) fmt.Printf(\u0026#34;Underlying array address: %p\\n\u0026#34;, \u0026amp;s[0]) fmt.Printf(\u0026#34;Length: %d\\n\u0026#34;, len(s)) fmt.Printf(\u0026#34;Capacity: %d\\n\u0026#34;, cap(s)) fmt.Printf(\u0026#34;%v\\n\u0026#34;, struct1) } Since the array pointers are the same, every modification in the struct1.array is automatically reflected in the slice s:\n1 2 3 fmt.Printf(\u0026#34;Before: s[1] == %d\\n\u0026#34;, s[1]) // 0 struct1.array[1] = 42 fmt.Printf(\u0026#34;After: s[1] == %d\\n\u0026#34;, s[1]) // 42 Passing a slice as argument to a function When a slice is passed as argument to a function, the underlying struct object is passed by value to the function, which means that the function receives a copy of the struct object.\nThe diagram below illustrates what happens when passing a slice s to the function giveMeSlice:\n1 2 3 func giveMeSlice(arg []int) { ... } giveMeSlice(s) Slice header is copied, but storage array is the sameEven though the function only receives a copy of the array pointer, it can still access the original elements by following the pointer. This explains why a function can modify the elements of a slice.\nBut when the function resizes a slice, then only its own copy of the length and capacity variables are updated and this update is not propagated to the original slice object.\nThe code below illustrates these considerations:\n1 2 3 4 5 6 7 8 9 10 11 func giveMeSlice(arg []int) { fmt.Printf(\u0026#34;[in function] Slice address: %p\\n\u0026#34;, \u0026amp;arg) // 0x8060 fmt.Printf(\u0026#34;[in function] Array address: %p\\n\u0026#34;, \u0026amp;arg[0]) // 0xe180 } func main() { var s []int = make([]int, 5, 7) fmt.Printf(\u0026#34;Slice address: %p\\n\u0026#34;, \u0026amp;s) // 0x8030 fmt.Printf(\u0026#34;Array address: %p\\n\u0026#34;, \u0026amp;s[0]) // 0xe180 giveMeSlice(s) } ","date":"2024-08-31T01:00:00Z","permalink":"https://takia.dev/go-understanding-slices/","title":"Understanding Go slices in depth"},{"content":"In this article, we will show how to use a function when your code expects an interface, and vice versa.\nFrom Function to Interface If you need to convert a function to a single-method interface, then you can define a method on the function type directly.\nFor instance, let\u0026rsquo;s say that you have the following function:\n1 2 3 func funcName() string { return \u0026#34;https://takia.dev\u0026#34; } And you need an object implementing this interface in order to user the userCode function.\n1 2 3 4 5 6 7 type Interface interface { MethodName() string } func userCode(i Interface) { println(i.MethodName()) } The following code creates a user-defined function type and defines a method MethodName on that type:\n1 2 3 4 5 type FuncType func() string func (f FuncType) MethodName() string { return f() } Which let\u0026rsquo;s you easily convert between the function and the interface as follows:\n1 2 var i Interface = FuncType(funcName) userCode(i) From Interface to Function To use a single-method interface where a function is expected, simply pass the interface\u0026rsquo;s method:\nLet\u0026rsquo;s say that you have an object implementing this interface:\n1 2 3 type Interface interface { MethodName() string } And you want to use funcUserCode that requires a function object:\n1 2 3 4 type FuncType func() string func funcUserCode(f FuncType) { println(f()) } Then, you can directly pass the method as argument:\n1 2 3 4 func convert(myObject Interface) { var function FuncType = myObject.MethodName funcUserCode(myObject.MethodName) } Or you can wrap the method call in an anonymous function:\n1 2 3 4 func convert(myObject Interface) { function := func() string { return i.MethodName() } funcUserCode(function) } ","date":"2024-08-31T00:00:00Z","permalink":"https://takia.dev/go-convert-functions-to-interfaces/","title":"Convert Functions to Interfaces and vice versa in Go"},{"content":"Types Booleans zero initialized when declared without a value cannot be modified by functions, unless when using a pointer 1 2 var zeroInitializedBool bool // false var valueBool bool = true Integers zero initialized when declared without a value cannot be modified by functions, unless when using a pointer 1 2 3 4 5 6 7 8 9 10 11 12 13 var zeroInitializedInt int // 0 var valueInt int = 5 // Other integer types have a minimum and maximum value var min8, max8 int8 = -128, 127 var min16, max16 int16 = -32768, 32767 var min32, max32 int32 = -2147483648, 2147483647 var min64, max64 int64 = -9223372036854775808, 9223372036854775807 var min_u8, max_u8 uint8 = 0, 255 var min_u16, max_u16 uint16 = 0, 65535 var min_u32, max_u32 uint32 = 0, 4294967295 var min_u64, max_u64 uint64 = 0, 18446744073709551615 Decimals (float) zero initialized when declared without a value cannot be modified by functions, unless when using a pointer 1 2 3 4 5 var max_f32 float32 = 3.40282346638528859811704183484516925440e+38 var smallest_f32 float32 = 1.401298464324817070923729583289916131280e-45 var max_f64 float64 = 1.797693134862315708145274237317043567981e+308 var smallest_f64 float64 = 4.940656458412465441765687928682213723651e-324 Runes zero initialized when declared without a value cannot be modified by functions, unless when using a pointer 1 2 3 4 5 6 7 var r1 rune = \u0026#39;A\u0026#39; // a line break var line_break rune = \u0026#39;\\n\u0026#39; // a unicode checkmark symbol ✓ var checkmark rune = \u0026#39;\\u2713\u0026#39; Pointers 1 2 3 var value int = 5 var pointer *int = \u0026amp;value println(value == *pointer) Arrays zero initialized when declared without a value cannot be modified by functions, unless when using a pointer 1 2 3 4 5 6 7 8 9 10 11 var arrayOfZeros [5]int var array = [5]int{0, 1, 2, 10: 10, 11} // note the colon : syntax to initialize the element at index 10 nElementsCopied := copy(dst, src) length := len(array) firstElement = array[0] lastElement = array[len(array)-1] fullSlice = array[:] subSlice = array[3:5] Slices Slices are dynamically allocated, variable-length arrays.\nThey are default initialized to nil. Their values can be modified in function, with caveats: Their length, capacity and memory location cannot be modified in functions because they are passed by value. However, the value of elements can be modidied by functions since they are accessed through the pointer. Their implementation can be illustrated as follows:\n1 2 3 4 5 struct slice { length int capacity int memory *T } Slices Cheatsheet:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var nilSlice []int // == nil var emptySlice = []int{} // length=0, capacity=0 var sliceWithValues = []int{ 0, 1, 2, 3, 10: 10, } var sliceWithLength = make([]int, length) var sliceWithLengthAndCapacity = make([]int, length, capacity) firstElement = slice[0] length := len(slice) slice = append(slice, element1, element2) slice = append(slice, ...otherSlice) yesno = slices.Equal(slice1, slice2) yesno = slice1 == nil nElementsCopied := copy(dst, src) Maps Implemented with pointers:\nThey are default initialized to nil, Their values can be modified in function, with caveats. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var nilMap map[string]int // == nil var emptyMap = map[string]int{} var mapWithValues = map[string]int{ \u0026#34;https://takia.dev\u0026#34;: 100, } var mapWithLength = make(map[string]int, length) // read v, ok := emptyMap[\u0026#34;hello\u0026#34;] if !ok { // ... } delete(mapWithValues, \u0026#34;key\u0026#34;) maps.Equal(map1, map2) Control Structures If statements 1 2 3 4 5 6 7 8 a := 5 if a == 5 { // ... } else if a \u0026gt; 5 { // ... } else { // ... } If statements can use if-local variables as follows:\n1 2 3 4 5 6 if n := rand.Intn(10); n \u0026lt; 5 { // n exists in this block } else { // n exists in this block too } // n does not exist outside the if block Switch statements Classic switch:\n1 2 3 4 5 6 switch value { case 0, 1, 2: // ... default: // ... } Empty switch:\n1 2 3 4 5 6 7 8 9 10 value := 0 switch { case value \u0026lt; 5: // ... case value \u0026gt; 5: // ... default: // ... } Switch-local variables:\n1 2 3 4 5 6 7 8 9 switch value := 5; { case value \u0026lt; 5: // ... } switch value := 5; value { case 0, 1, 2: // ... } For loops Classic C-style for loop:\n1 2 for i := 0; i \u0026lt; 10; i++ { } Condition-only for loop:\n1 2 3 4 i := 0 for i \u0026lt; 10 { i += 1 } Sequence iteration:\n1 2 3 4 s := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} for index, value := range s { println(index, value) } Map iteration:\n1 2 3 4 m := map[string]string{\u0026#34;key1\u0026#34;: \u0026#34;value1\u0026#34;} for key, value := range m { println(key, value) } String iteration (as array of rune):\n1 2 3 4 5 str := \u0026#34;Hello 😊\u0026#34; for index, rune := range str { // for iterates over runes, not bytes println(index, rune) } Labeled for loops allow using break or continue on an outer loop from an inner loop:\n1 2 3 4 5 6 7 8 // labeled for loop outer: for i_outer := range []int{1, 2, 3, 4} { for i_inner := range []int{1, 2, 3} { unused(i_outer, i_inner) continue outer } } Goto statements Goto statements can be use to skip over blocks of code. Although it should only be sparingly used, it can sometimes come handy for error handling. Use of defer is preferred when possible.\n1 2 3 4 5 6 7 8 jumpOver := true if jumpOver { goto skip } println(\u0026#34;This statement will be skipped\u0026#34;) skip: // ... Functions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func simpleFunction(arg1 int, arg2 int) int { return arg1 + arg2 } func genericFunction[T any](arg1 T) T { return arg1 } func variadicFunction(vals ...int) int { result := 0 for _, v := range vals { result += v } return result } func multipleReturnValues() (int, error) { return 0, nil } func namedReturnValues() (retA int, err error) { // defer registers statements to be executed at exit // named return values allows defer to modify them defer func() { if err != nil { retA = 0 // rollback code } }() return 1, nil } Functions can be stored in variables:\n1 2 3 4 5 6 // Function variables var myfunc func(int, int) int = simpleFunction // Function types type FuncType func(int, int) int var myfunc2 FuncType = simpleFunction Anonymous Function can access outer variables:\n1 2 3 4 5 6 7 8 9 func f() { outerVariable := 5 setValue := func(arg int) { outerVariable = arg } setValue(7) println(outerVariable) } User-Defined types User-Defined types User-Defined type can be declared as follows:\n1 type NewType ExistingType There is no implicit cast between user-defined types. The code belows shows how this can be exploited to ensure that every string has been escaped before it is displayed on a webpage:\n1 2 3 4 5 6 7 8 9 10 type EscapedString string func safeEscape(s string) EscapedString { escaped := s //html.EscapeString(s) return EscapedString(escaped) } func displayOnPage(s EscapedString) { // ... } Structs Structs are passed by value, they cannot be modified by functions unless when using a pointer. Struct fields are default initialized to their respective zero values.\n1 2 3 4 5 6 7 8 9 type person struct { name string age int } var structOfZeros person // == {\u0026#34;\u0026#34;, 0} var julien = person{\u0026#34;Julien\u0026#34;, 30} var alisha = person{name: \u0026#34;Alisha\u0026#34;} alisha.age = 30 Methods \u0026amp; Member functions Methods can be defined on user-defined types as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type person struct { name string age int } // value-receiver methods cannot modify the instance func (p person) String() string { return fmt.Sprintf(\u0026#34;%s (age:%d)\u0026#34;, p.name, p.age) } // pointer-receiver methods can modify the instance func (p *person) GrowOld() { // handle case where p == nil! p.age += 1 } Go will automatically reference or dereference values and pointer to match the value-receiver method or pointer-receiver method. But remember that value-receiver methods work on a copy of the object and therefore should not attempt to modify its member values.\n1 2 3 4 5 6 7 p1 := person{\u0026#34;Julien\u0026#34;, 30} p1.String() p1.GrowOld() // auto reference p2 = \u0026amp;p1 p2.String() // auto dereference p2.GrowOld() Type Embeddings Type embeddings embed one InnerType inside an OuterType and make methods defined on InnerType available on instances of OuterType:\nFor instance, the given Inner type:\n1 2 3 4 5 6 7 type Inner struct { innerField int } func (i Inner) ShowInnerField() { println(i.innerField) } Can be embedded inside an Outer type as follows:\n1 2 3 4 5 6 7 8 9 10 11 type Outer struct { Inner outerField int } o := Outer{ Inner: Inner{ innerField: 5, }, outerField: 10, } And the Inner method can be called on the Outer object:\n1 o.ShowInnerField() Embedding merge the method set of Inner and Outer making it possible to implement interfaces more easily. But beware that:\nEmbeddings are not inheritance:\nthey do not provide implicit slicing or type cast from derived type to parent type they do not provide dynamic dispatch and method resolution Interfaces Interfaces specify what the caller code needs, they define the set of method than an object is expected to offer. Interfaces are similar to python\u0026rsquo;s Protocols: unlike in Java they are implemented implicitly.\n1 2 3 type Provider interface { ProviderID() string } Any object with a Read() string method automatically implements the Reader interface.\n1 2 3 4 5 6 type MyProvider struct { name string } func (p MyProvider) ProviderID() string { return p.name } The following function requests a Provider instance and can be used with our MyProvider object implicitely:\n1 2 3 4 5 6 func useProvider(p Provider) { // ... } var p = MyProvider{\u0026#34;name\u0026#34;} useProvider(p) Interface Embeddings Interfaces can be merged together using interface embeddings:\n1 2 3 4 5 6 7 type Reader interface{} type Writer interface{} type ReadWriter interface { Reader Writer } nil Interfaces Under the hood, interface are implemented with two pointers: one for the instance and one for the instance type:\n1 2 3 4 type Interface[T any] struct { type *Type[T] value *T } An interface is considered nil if it has not been assigned a type. In the code below, even though nilInstance is set to the nil pointer, the nilInterface object is assigned the Object type and therefore does not evaluate to nil:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Interface interface { Method() } type Object struct{} func (o Object) Method() { } var nilInstance *O var notNilInterface I = nilInstance println(\u0026#34;Instance is nil:\u0026#34;, nilInstance == nil) // true println(\u0026#34;Interface is nil:\u0026#34;, notNilInterface == nil) // false A common pitfall is to pre-declare the error variable to return at the end of a function as in this snippet:\n1 2 3 4 5 6 7 8 9 10 type CustomError struct {} func (c CustomError) Error() string { return \u0026#34;message\u0026#34; } func brokenFunction(arg int) error { var err CustomError; // nil CustomError if arg \u0026lt; 0 { err = CustomError{} } return err // BUG! The error interface is not nil } The function would then be used as follows:\n1 2 3 4 var err error = brokenFunction(5) if err != nil { println(\u0026#34;ERROR\u0026#34;) } Which will always enter the error block because the error interface does not evaluate to nil. (Its type pointer is assigned to CustomError!)\nTo avoid this pitfall, declare variables of the error type instead of the custom error type.\nEnums Go uses iota, a special counter whose value increases for each constant in a const block. It can be used to assign increasing values to consecutive const values. Note that it is possible to use _ to disable the default value.\n1 2 3 4 5 6 7 type EnumType int const ( EnumDefaultValue EnumType = iota EnumValue1 EnumValue2 EnumValue3 ) Generics A function or type is said generic when it accepts type arguments. Type arguments are passed between square brackets []. In the code below, the generic type argument T implements the comparable constraint. Any interface can be used as a type constraint.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 type Set[T comparable] struct { storage map[T]bool } func (s *Set[T]) add(value T) { if s.storage == nil { s.storage = map[T]bool{} } s.storage[value] = true } func (s *Set[T]) remove(value T) { delete(s.storage, value) } func (s Set[T]) contains(value T) bool { return s.storage[value] } var s = Set[int]{} s.add(5) println(\u0026#34;Set contains 5?\u0026#34;, s.contains(5)) s.remove(5) ","date":"2024-08-31T00:00:00Z","permalink":"https://takia.dev/go-cheatsheet/","title":"Go cheatsheet"}]